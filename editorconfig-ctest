#!/bin/python3

import os
import sys
import logging
import re

from editorconfig import get_properties, exceptions


default_ignores = [
    '.git/',
    'builddir',
]


def should_be_tested(filename):
    for ignore in default_ignores:
        if ignore in filename:
            logging.debug(filename + ': ignored')
            return False
    # todo: local ignore list, parse .gitignore
    return True


def options_to_str(options):
    out = '['
    for key, value in options.items():
        out += '(' + key + ': ' + value + '), '
    out = out[:-2] + ']'
    return out


ctest_fail_counter = None


def ctest_charset(filename, value):
    pass  # honestly who doesn't use utf-8 anyway


def ctest_end_of_line(filename, value):
    pass  # honestly who doesn't use \n anyway


def ctest_trim_trailing_whitespace(filename, value):
    global ctest_fail_counter
    if value:
        file = open(filename, mode='r')
        line_count = 0
        for line in file:
            line_count += 1
            if re.match(r'.*\s\n$', line):
                ctest_fail_counter += 1
                logging.info(filename + ': non-trimmed trailing whitespace found in line ' + str(line_count))


def ctest_insert_final_newline(filename, value):
    global ctest_fail_counter
    if value:
        file = open(filename, mode='r')
        for line in file:
            pass
        if not re.match(r'.*\n$', line):
            ctest_fail_counter += 1
            logging.info(filename + ': missing final newline found')


def ctest_indent_style(filename, value):
    pass  # todo


def ctest_indent_size(filename, value):
    pass  # todo


def ctest_max_line_length(filename, value, tab_width):
    global ctest_fail_counter
    file = open(filename, mode='r')
    line_count = 0
    for line in file:
        line_count += 1
        line = re.sub(r'\n$', '', line)
        tab_replace = ''
        for i in range(tab_width):
            tab_replace += ' '
        line = re.sub(r'^\t+', tab_replace, line)
        if len(line) > value:
            ctest_fail_counter += 1
            logging.info(filename + ': too long line found in line ' + str(line_count))


def ctest(filename):
    if should_be_tested(filename):
        try:
            options = get_properties(filename)
            logging.debug(filename + ': options are ' + options_to_str(options))
            # todo: open file only once?
            # todo: auto-ignore non-text files
            if 'charset' in options:
                ctest_charset(filename, options['charset'])
            if 'end_of_line' in options:
                ctest_end_of_line(filename, options['end_of_line'])
            if 'trim_trailing_whitespace' in options:
                ctest_trim_trailing_whitespace(filename, options['trim_trailing_whitespace'])
            if 'insert_final_newline' in options:
                ctest_insert_final_newline(filename, options['insert_final_newline'])
            if 'indent_style' in options:
                ctest_indent_style(filename, options['indent_style'])
            if 'indent_size' in options:
                ctest_indent_size(filename, options['indent_size'])
            if 'max_line_length' in options:
                tab_width = 1
                if 'tab_width' in options:
                    tab_width = int(options['tab_width'])
                ctest_max_line_length(filename, int(options['max_line_length']), tab_width)
        except exceptions.ParsingError:
            logging.warning(filename + ': error parsing an .editorconfig file', exc_info=True)
        except exceptions.PathError:
            logging.error(filename + ': invalid filename specified', exc_info=True)
        except exceptions.EditorConfigError:
            logging.error(filename + ': unknown EditorConfig error occurred', exc_info=True)


if __name__ == "__main__":
    logging.basicConfig(level=logging.INFO)  # todo: add cmdline option to change logging level

    testdir = os.getcwd()  # todo: add cmdline option to change dir

    ctest_fail_counter = 0

    for (dirpath, dirnames, filenames) in os.walk(testdir):
        for filename in filenames:
            ctest(os.path.join(dirpath, filename))

    exit_status = 0
    if ctest_fail_counter > 0:
        exit_status = 1
    logging.info('found ' + str(ctest_fail_counter) + ' conformance issues')

    exit_status = 0  # for debugging purposes, add cmdline option to always exit with 0

    sys.exit(exit_status)
